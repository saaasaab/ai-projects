<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topology Analysis Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/geotiff@2.0.7/dist/geotiff.bundle.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .panel {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        .panel h2 {
            color: #4a5568;
            margin-bottom: 20px;
            font-size: 1.5rem;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 10px;
        }

        .property-selector {
            margin-bottom: 20px;
        }

        .property-selector label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4a5568;
        }

        .property-selector select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 16px;
            background: white;
            transition: border-color 0.3s ease;
        }

        .property-selector select:focus {
            outline: none;
            border-color: #667eea;
        }

        .analyze-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .analyze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .analyze-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .topology-score {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .score-value {
            font-size: 4rem;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .score-grade {
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .score-description {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .steepness-chart {
            height: 300px;
            position: relative;
        }

        .buildable-areas {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .area-card {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .area-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }

        .area-card.buildable {
            border-color: #48bb78;
            background: #f0fff4;
        }

        .area-card.moderate {
            border-color: #ed8936;
            background: #fffaf0;
        }

        .area-card.steep {
            border-color: #f56565;
            background: #fff5f5;
        }

        .area-percentage {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .area-label {
            font-size: 1rem;
            color: #4a5568;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #4a5568;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        .map-container {
            margin-bottom: 20px;
        }

        .map-instructions {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .map-instructions ul {
            margin-left: 20px;
            margin-top: 10px;
        }

        .map-instructions li {
            margin-bottom: 5px;
            color: #4a5568;
        }

        .property-info {
            background: #f0fff4;
            border: 2px solid #48bb78;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .property-info h3 {
            color: #2f855a;
            margin-bottom: 15px;
        }

        .property-info p {
            margin-bottom: 10px;
            color: #4a5568;
        }

        .property-info span {
            font-weight: 600;
            color: #2f855a;
        }

        #map {
            border: 2px solid #e2e8f0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .leaflet-popup-content {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        @media (max-width: 768px) {
            .main-content,
            .results-section {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Topology Analysis Tool</h1>
            <p>Analyze property topography, steepness, and buildability</p>
        </div>

        <div class="main-content">
            <div class="panel">
                <h2>Property Selection</h2>
                <div class="map-container">
                    <div id="map" style="height: 400px; border-radius: 10px; margin-bottom: 20px;"></div>
                    <div class="map-instructions">
                        <p><strong>Instructions:</strong></p>
                        <ul>
                            <li>Click anywhere on the map to select a property location</li>
                            <li>Use mouse wheel to zoom in/out</li>
                            <li>Drag to pan around the map</li>
                        </ul>
                    </div>
                </div>
                <div class="property-info hidden" id="propertyInfo">
                    <h3>Selected Location</h3>
                    <p><strong>Coordinates:</strong> <span id="coordinates"></span></p>
                    <p><strong>Address:</strong> <span id="address"></span></p>
                    <button id="analyzeBtn" class="analyze-btn">Analyze Topology</button>
                </div>
            </div>

            <div class="panel">
                <h2>Topology Score</h2>
                <div id="topologyScore" class="topology-score hidden">
                    <div class="score-value" id="scoreValue">0</div>
                    <div class="score-grade" id="scoreGrade">Grade</div>
                    <div class="score-description" id="scoreDescription">Description</div>
                </div>
                <div id="scoreLoading" class="loading hidden">
                    <div class="spinner"></div>
                    <p>Fetching elevation data and analyzing topology...</p>
                </div>
            </div>
        </div>

        <div id="resultsSection" class="results-section hidden">
            <div class="panel full-width">
                <h2>3D Topology Visualization</h2>
                <div id="threeContainer" style="height: 400px; border-radius: 10px; overflow: hidden;"></div>
            </div>

            <div class="panel">
                <h2>Steepness Distribution</h2>
                <div class="steepness-chart">
                    <canvas id="steepnessChart"></canvas>
                </div>
            </div>

            <div class="panel">
                <h2>Buildable Areas</h2>
                <div id="buildableAreas" class="buildable-areas">
                    <!-- Buildable area cards will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        class TopologyAnalyzer {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.currentProperty = null;
                this.steepnessChart = null;
                this.map = null;
                this.selectedMarker = null;
                this.selectedLocation = null;
                
                this.initializeMap();
                this.initializeEventListeners();
                // Don't initialize Three.js yet - wait until it's needed
            }

            initializeMap() {
                // Initialize Leaflet map centered on Portland, Oregon
                this.map = L.map('map').setView([45.5152, -122.6784], 11); // Portland, OR coordinates
                
                // Add OpenStreetMap tiles
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenStreetMap contributors'
                }).addTo(this.map);

                // Add click event to map
                this.map.on('click', (e) => {
                    this.handleMapClick(e.latlng);
                });
            }

            handleMapClick(latlng) {
                // Remove previous marker
                if (this.selectedMarker) {
                    this.map.removeLayer(this.selectedMarker);
                }

                // Add new marker
                this.selectedMarker = L.marker(latlng).addTo(this.map);
                this.selectedLocation = latlng;

                // Get address from coordinates
                this.reverseGeocode(latlng);
            }

            async reverseGeocode(latlng) {
                try {
                    const response = await fetch(
                        `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latlng.lat}&lon=${latlng.lng}&zoom=18&addressdetails=1`
                    );
                    const data = await response.json();
                    
                    const address = data.display_name || 'Address not available';
                    const coordinates = `${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}`;
                    
                    document.getElementById('coordinates').textContent = coordinates;
                    document.getElementById('address').textContent = address;
                    document.getElementById('propertyInfo').classList.remove('hidden');
                } catch (error) {
                    console.error('Error getting address:', error);
                    document.getElementById('address').textContent = 'Address not available';
                    document.getElementById('propertyInfo').classList.remove('hidden');
                }
            }

            initializeEventListeners() {
                const analyzeBtn = document.getElementById('analyzeBtn');

                analyzeBtn.addEventListener('click', () => {
                    if (this.selectedLocation) {
                        this.analyzeTopology();
                    }
                });
            }

            initializeThreeJS() {
                const container = document.getElementById('threeContainer');
                console.log('=== INITIALIZING THREE.JS ===');
                console.log('Container element:', container);
                console.log('Container dimensions:', container.clientWidth, 'x', container.clientHeight);
                console.log('Container style:', window.getComputedStyle(container));
                console.log('Container parent:', container.parentElement);
                
                // Ensure container has dimensions
                if (container.clientWidth === 0 || container.clientHeight === 0) {
                    console.warn('Container has no dimensions, using fallback size');
                    container.style.width = '100%';
                    container.style.height = '400px';
                    console.log('Updated container dimensions:', container.clientWidth, 'x', container.clientHeight);
                }
                
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf0f0f0);

                // Camera setup
                this.camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                this.camera.position.set(50, 50, 50);

                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(this.renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);

                // Grid helper
                const gridHelper = new THREE.GridHelper(100, 20, 0x888888, 0xcccccc);
                this.scene.add(gridHelper);

                // Start render loop
                this.animate();

                // Handle window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = container.clientWidth / container.clientHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(container.clientWidth, container.clientHeight);
                });
                
                console.log('Three.js initialized successfully');
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (this.controls) {
                    this.controls.update();
                }
                
                this.renderer.render(this.scene, this.camera);
            }

            async analyzeTopology() {
                if (!this.selectedLocation) return;

                this.showLoading();
                
                try {
                    // Fetch elevation data from OpenTopography API
                    const elevationData = await this.fetchElevationData();
                    console.log('Fetched elevation data:', elevationData);
                    
                    // Analyze the topology data
                    this.currentProperty = this.analyzeElevationData(elevationData);
                    console.log('Analyzed property data:', this.currentProperty);
                    
                    this.displayResults();
                } catch (error) {
                    console.error('Error analyzing topology:', error);
                    // Fallback to simulated data if API fails
                    this.currentProperty = this.generateFallbackData();
                    console.log('Using fallback data:', this.currentProperty);
                    this.displayResults();
                }
                
                this.hideLoading();
            }

            async fetchElevationData() {
                const { lat, lng } = this.selectedLocation;
                console.log(`Fetching elevation data for coordinates: ${lat}, ${lng}`);
                
                try {
                    // Using OpenTopography API for real elevation data
                    const apiKey = '';
                    const url = `https://portal.opentopography.org/API/usgsdem?datasetName=USGS30m&south=${(lat-0.01).toFixed(6)}&north=${(lat+0.01).toFixed(6)}&west=${(lng-0.01).toFixed(6)}&east=${(lng+0.01).toFixed(6)}&outputFormat=GTiff&API_Key=${apiKey}`;
                    
                    console.log('OpenTopography API URL:', url);
                    
                    // Try OpenTopography API first
                    try {
                        const topoResponse = await fetch(url);
                        if (topoResponse.ok) {
                            console.log('OpenTopography API response successful');
                            
                            // Process the GTiff response
                            const arrayBuffer = await topoResponse.arrayBuffer();
                            console.log('=== OPENTOPGRAPHY DATA RECEIVED ===');
                            console.log('GTiff data size:', arrayBuffer.byteLength, 'bytes');
                            console.log('ArrayBuffer type:', arrayBuffer.constructor.name);
                            console.log('First 100 bytes:', new Uint8Array(arrayBuffer.slice(0, 100)));
                            
                            // Parse GTiff data to extract elevation values
                            const elevationData = await this.parseGTiffData(arrayBuffer, lat, lng);
                            console.log('=== PARSED ELEVATION DATA ===');
                            console.log('Full elevation data object:', elevationData);
                            
                            if (elevationData && elevationData.samples && elevationData.samples.length > 0) {
                                console.log('=== RETURNING ELEVATION DATA ===');
                                console.log('Base elevation:', elevationData.baseElevation);
                                console.log('Sample count:', elevationData.samples.length);
                                console.log('First 5 samples:', elevationData.samples.slice(0, 5));
                                
                                return {
                                    elevation: elevationData.baseElevation,
                                    samples: elevationData.samples,
                                    terrain: this.analyzeTerrainComplexity(lat, lng)
                                };
                            }
                        } else {
                            console.log('OpenTopography API response not ok:', topoResponse.status);
                        }
                    } catch (topoError) {
                        console.log('OpenTopography API call failed:', topoError);
                    }
                    
                    // Fallback elevation service (commented out for now)
                    /*
                    const response = await fetch(`https://api.open-elevation.com/api/v1/lookup?locations=${lat},${lng}`);
                    
                    if (!response.ok) {
                        throw new Error(`Elevation API error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    console.log('Raw elevation API response:', data);
                    
                    if (data.results && data.results.length > 0) {
                        const baseElevation = data.results[0].elevation;
                        console.log(`Real elevation from API: ${baseElevation}m`);
                        
                        // Generate realistic terrain samples around the base elevation
                        const samples = this.generateElevationSamples(baseElevation, lat, lng);
                        
                        return {
                            elevation: baseElevation,
                            samples: samples,
                            terrain: this.analyzeTerrainComplexity(lat, lng)
                        };
                    } else {
                        throw new Error('No elevation data returned from API');
                    }
                    */
                    
                    // If OpenTopography fails, throw error
                    throw new Error('OpenTopography API failed and fallback is disabled');
                    
                } catch (error) {
                    console.error('Error fetching elevation data:', error);
                    console.log('Falling back to simulated data...');
                    
                    // Fallback to simulated data if API fails
                    const baseElevation = this.getBaseElevation(lat, lng);
                    return {
                        elevation: baseElevation,
                        samples: this.generateElevationSamples(baseElevation, lat, lng),
                        terrain: this.analyzeTerrainComplexity(lat, lng)
                    };
                }
            }

            getBaseElevation(lat, lng) {
                // Simulate elevation based on latitude (higher near poles, lower near equator)
                // and longitude (variations for different regions)
                const latFactor = Math.abs(lat) / 90;
                const lngFactor = Math.sin(lng * Math.PI / 180);
                
                const elevation = 50 + (latFactor * 200) + (lngFactor * 100);
                console.log(`Base elevation for ${lat}, ${lng}: ${elevation}m`);
                return elevation;
            }

            generateElevationSamples(baseElevation, lat, lng) {
                const samples = [];
                const numSamples = 100;
                const gridSize = Math.sqrt(numSamples);
                
                console.log(`Generating ${numSamples} elevation samples around base elevation ${baseElevation}m`);
                
                // Create a more realistic terrain pattern based on geographic location
                // Different regions have different terrain characteristics
                const terrainVariation = this.getTerrainVariationForLocation(lat, lng);
                
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const x = (i / gridSize) * 1000; // 1km area
                        const y = (j / gridSize) * 1000;
                        
                        // Generate realistic terrain variations based on location
                        const elevation = baseElevation + 
                            Math.sin(x * terrainVariation.frequency1) * Math.cos(y * terrainVariation.frequency1) * terrainVariation.amplitude1 +
                            Math.sin(x * terrainVariation.frequency2) * Math.cos(y * terrainVariation.frequency2) * terrainVariation.amplitude2 +
                            Math.sin(x * terrainVariation.frequency3) * Math.cos(y * terrainVariation.frequency3) * terrainVariation.amplitude3;
                        
                        samples.push({ x, y, elevation });
                    }
                }
                
                console.log(`Generated ${samples.length} elevation samples with terrain variation:`, terrainVariation);
                return samples;
            }

            getTerrainVariationForLocation(lat, lng) {
                // Different terrain characteristics based on geographic location
                // Portland area (45.5°N, -122.7°W) - generally hilly with some flat areas
                if (lat > 45.0 && lat < 46.0 && lng > -123.0 && lng < -122.0) {
                    return {
                        frequency1: 0.008, // Large hills
                        amplitude1: 25,
                        frequency2: 0.015, // Medium variations
                        amplitude2: 15,
                        frequency3: 0.03, // Small details
                        amplitude3: 8
                    };
                }
                
                // Mountainous regions (higher latitudes, near mountain ranges)
                if (Math.abs(lat) > 40) {
                    return {
                        frequency1: 0.01, // Large mountains
                        amplitude1: 50,
                        frequency2: 0.02, // Medium variations
                        amplitude2: 25,
                        frequency3: 0.04, // Small details
                        amplitude3: 10
                    };
                }
                
                // Coastal/flat regions (lower latitudes, near coasts)
                if (Math.abs(lat) < 30) {
                    return {
                        frequency1: 0.005, // Gentle slopes
                        amplitude1: 10,
                        frequency2: 0.01, // Small variations
                        amplitude2: 5,
                        frequency3: 0.02, // Fine details
                        amplitude3: 2
                    };
                }
                
                // Default terrain (moderate hills)
                return {
                    frequency1: 0.008,
                    amplitude1: 20,
                    frequency2: 0.015,
                    amplitude2: 12,
                    frequency3: 0.03,
                    amplitude3: 6
                };
            }

            analyzeTerrainComplexity(lat, lng) {
                // Analyze terrain complexity based on location
                let complexity;
                
                // Portland area - generally hilly with some flat areas
                if (lat > 45.0 && lat < 46.0 && lng > -123.0 && lng < -122.0) {
                    complexity = {
                        flat: 0.25 + (Math.random() * 0.2), // 25-45% flat
                        moderate: 0.4 + (Math.random() * 0.3), // 40-70% moderate
                        steep: 0.1 + (Math.random() * 0.2) // 10-30% steep
                    };
                }
                // Mountainous regions
                else if (Math.abs(lat) > 40) {
                    complexity = {
                        flat: 0.1 + (Math.random() * 0.2), // 10-30% flat
                        moderate: 0.2 + (Math.random() * 0.3), // 20-50% moderate
                        steep: 0.4 + (Math.random() * 0.4) // 40-80% steep
                    };
                }
                // Coastal/flat regions
                else if (Math.abs(lat) < 30) {
                    complexity = {
                        flat: 0.6 + (Math.random() * 0.3), // 60-90% flat
                        moderate: 0.2 + (Math.random() * 0.2), // 20-40% moderate
                        steep: 0.05 + (Math.random() * 0.1) // 5-15% steep
                    };
                }
                // Default - moderate hills
                else {
                    complexity = {
                        flat: 0.3 + (Math.random() * 0.3), // 30-60% flat
                        moderate: 0.3 + (Math.random() * 0.3), // 30-60% moderate
                        steep: 0.1 + (Math.random() * 0.2) // 10-30% steep
                    };
                }
                
                // Normalize to 100%
                const total = complexity.flat + complexity.moderate + complexity.steep;
                complexity.flat /= total;
                complexity.moderate /= total;
                complexity.steep /= total;
                
                console.log(`Terrain complexity for ${lat}, ${lng}:`, complexity);
                return complexity;
            }

            async parseGTiffData(arrayBuffer, lat, lng) {
                console.log('Parsing GTiff data with GeoTIFF library...');
                
                try {
                    // Parse the GTiff data using the GeoTIFF library
                    const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
                    const image = await tiff.getImage();
                    const rasters = await image.readRasters();
                    
                    console.log('GTiff parsed successfully:', {
                        width: image.getWidth(),
                        height: image.getHeight(),
                        samplesPerPixel: image.getSamplesPerPixel(),
                        dataType: image.getDataType()
                    });
                    
                    // Extract elevation data from the raster
                    const elevationData = rasters[0]; // First band contains elevation values
                    const width = image.getWidth();
                    const height = image.getHeight();
                    
                    console.log('Elevation data extracted:', {
                        dataLength: elevationData.length,
                        minElevation: Math.min(...elevationData),
                        maxElevation: Math.max(...elevationData)
                    });
                    
                    // Get image bounds and transform information
                    const bbox = image.getBoundingBox();
                    const pixelWidth = (bbox[2] - bbox[0]) / width;
                    const pixelHeight = (bbox[1] - bbox[3]) / height;
                    
                    console.log('Image bounds:', bbox);
                    console.log('Pixel dimensions:', pixelWidth, 'x', pixelHeight);
                    
                    // Convert elevation data to samples with coordinates
                    const samples = [];
                    const baseElevation = elevationData[Math.floor(elevationData.length / 2)]; // Center point
                    
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const index = y * width + x;
                            const elevation = elevationData[index];
                            
                            // Convert pixel coordinates to geographic coordinates
                            const geoX = bbox[0] + (x + 0.5) * pixelWidth;
                            const geoY = bbox[3] + (y + 0.5) * pixelHeight;
                            
                            // Convert to local coordinates (meters) for 3D visualization
                            const localX = (geoX - lng) * 111320 * Math.cos(lat * Math.PI / 180); // Convert to meters
                            const localY = (geoY - lat) * 111320; // Convert to meters
                            
                            samples.push({
                                x: localX,
                                y: localY,
                                elevation: elevation,
                                geoX: geoX,
                                geoY: geoY
                            });
                        }
                    }
                    
                    console.log(`Generated ${samples.length} elevation samples from GTiff data`);
                    
                    return {
                        baseElevation: baseElevation,
                        samples: samples,
                        bounds: bbox,
                        pixelDimensions: { width: pixelWidth, height: pixelHeight }
                    };
                    
                } catch (error) {
                    console.error('Error parsing GTiff data:', error);
                    throw error;
                }
            }

            analyzeElevationData(elevationData) {
                const { elevation, samples, terrain } = elevationData;
                console.log('Starting elevation data analysis with:', { elevation, samplesCount: samples.length, terrain });
                
                // Calculate elevation range
                const elevations = samples.map(s => s.elevation);
                const minElevation = Math.min(...elevations);
                const maxElevation = Math.max(...elevations);
                const elevationRange = maxElevation - minElevation;
                console.log('Elevation range:', { min: minElevation, max: maxElevation, range: elevationRange });
                
                // Calculate steepness based on elevation changes
                const steepness = this.calculateSteepness(samples);
                console.log('Calculated steepness:', steepness);
                
                // Calculate buildable area percentage
                const buildable = this.calculateBuildableArea(steepness);
                console.log('Buildable area percentage:', buildable);
                
                // Calculate topology score
                const score = this.calculateTopologyScore(steepness, elevationRange);
                console.log('Topology score:', score);
                
                // Determine property type based on characteristics
                const propertyType = this.determinePropertyType(steepness, elevationRange);
                console.log('Property type determined:', propertyType);
                
                const result = {
                    name: propertyType,
                    coordinates: this.selectedLocation,
                    elevation: { 
                        min: Math.round(minElevation), 
                        max: Math.round(maxElevation),
                        average: Math.round(elevation)
                    },
                    steepness: steepness,
                    buildable: buildable,
                    score: score,
                    samples: samples
                };
                
                console.log('Final analyzed property result:', result);
                return result;
            }

            calculateSteepness(samples) {
                console.log('=== CALCULATING STEEPNESS FROM REAL ELEVATION DATA ===');
                console.log('Sample count:', samples.length);
                console.log('Sample structure:', samples[0]);
                
                if (!samples || samples.length === 0) {
                    console.warn('No samples provided for steepness calculation');
                    return { flat: 0.33, moderate: 0.34, steep: 0.33 };
                }
                
                // Calculate slopes between adjacent elevation points
                const slopes = [];
                const sampleDistance = 30; // 30m between samples (USGS 30m DEM)
                
                // Create a grid-like structure from the samples
                const xCoords = [...new Set(samples.map(s => s.x))].sort((a, b) => a - b);
                const yCoords = [...new Set(samples.map(s => s.y))].sort((a, b) => a - b);
                
                console.log('Coordinate ranges:', { xCoords: xCoords.length, yCoords: yCoords.length });
                console.log('X range:', Math.min(...xCoords), 'to', Math.max(...xCoords));
                console.log('Y range:', Math.min(...yCoords), 'to', Math.max(...yCoords));
                
                // Calculate slopes between adjacent points
                for (let i = 0; i < samples.length - 1; i++) {
                    for (let j = i + 1; j < samples.length; j++) {
                        const sample1 = samples[i];
                        const sample2 = samples[j];
                        
                        // Calculate distance between points
                        const distance = Math.sqrt((sample2.x - sample1.x) ** 2 + (sample2.y - sample1.y) ** 2);
                        
                        // Only consider nearby points (within 60m)
                        if (distance <= 60 && distance > 0) {
                            const elevationDiff = Math.abs(sample2.elevation - sample1.elevation);
                            const slope = elevationDiff / distance; // Rise over run
                            slopes.push(slope);
                        }
                    }
                }
                
                console.log('Calculated', slopes.length, 'slopes from elevation data');
                console.log('Sample slopes:', slopes.slice(0, 10));
                console.log('Slope statistics:', {
                    min: Math.min(...slopes),
                    max: Math.max(...slopes),
                    avg: slopes.reduce((a, b) => a + b, 0) / slopes.length
                });
                
                if (slopes.length === 0) {
                    console.warn('No valid slopes calculated, using fallback');
                    return { flat: 0.33, moderate: 0.34, steep: 0.33 };
                }
                
                // Categorize slopes based on percentage grades
                const flat = slopes.filter(s => s <= 0.05).length / slopes.length; // 0-5% grade
                const moderate = slopes.filter(s => s > 0.05 && s <= 0.15).length / slopes.length; // 5-15% grade
                const steep = slopes.filter(s => s > 0.15).length / slopes.length; // >15% grade
                
                const result = { flat, moderate, steep };
                console.log('=== STEEPNESS CATEGORIZATION RESULTS ===');
                console.log('Flat (0-5%):', (flat * 100).toFixed(1) + '%');
                console.log('Moderate (5-15%):', (moderate * 100).toFixed(1) + '%');
                console.log('Steep (>15%):', (steep * 100).toFixed(1) + '%');
                console.log('Total:', ((flat + moderate + steep) * 100).toFixed(1) + '%');
                
                return result;
            }

            calculateBuildableArea(steepness) {
                // Areas with slope <= 5% are considered highly buildable
                return steepness.flat;
            }

            calculateTopologyScore(steepness, elevationRange) {
                // Score based on steepness and elevation range
                let score = 100;
                
                // Penalize for steep areas
                score -= steepness.steep * 40;
                score -= steepness.moderate * 20;
                
                // Penalize for extreme elevation changes
                if (elevationRange > 100) score -= 20;
                if (elevationRange > 200) score -= 30;
                
                return Math.max(0, Math.min(100, Math.round(score)));
            }

            determinePropertyType(steepness, elevationRange) {
                if (steepness.steep > 0.6) return 'Mountain Property';
                if (steepness.steep > 0.3) return 'Hillside Property';
                if (elevationRange < 50) return 'Plateau Property';
                if (steepness.flat > 0.6) return 'Valley Property';
                return 'Mixed Terrain Property';
            }

            generateFallbackData() {
                // Fallback data if API fails
                return {
                    name: 'Sample Property',
                    coordinates: this.selectedLocation,
                    elevation: { min: 100, max: 150, average: 125 },
                    steepness: { flat: 0.4, moderate: 0.4, steep: 0.2 },
                    buildable: 0.4,
                    score: 70
                };
            }

            displayResults() {
                console.log('=== DISPLAYING RESULTS ===');
                console.log('Current property data:', this.currentProperty);
                
                document.getElementById('resultsSection').classList.remove('hidden');
                console.log('Results section made visible');
                
                this.updateTopologyScore();
                console.log('Topology score updated');
                
                this.create3DVisualization();
                console.log('3D visualization created');
                
                this.createSteepnessChart();
                console.log('Steepness chart created');
                
                this.updateBuildableAreas();
                console.log('Buildable areas updated');
                
                console.log('=== RESULTS DISPLAY COMPLETE ===');
            }

            updateTopologyScore() {
                const score = this.currentProperty.score;
                const scoreElement = document.getElementById('topologyScore');
                const scoreValue = document.getElementById('scoreValue');
                const scoreGrade = document.getElementById('scoreGrade');
                const scoreDescription = document.getElementById('scoreDescription');

                scoreElement.classList.remove('hidden');

                scoreValue.textContent = score;

                if (score >= 90) {
                    scoreGrade.textContent = 'A+ (Excellent)';
                    scoreDescription.textContent = 'Highly suitable for development with minimal grading required';
                } else if (score >= 80) {
                    scoreGrade.textContent = 'A (Very Good)';
                    scoreDescription.textContent = 'Very suitable for development with minor grading';
                } else if (score >= 70) {
                    scoreGrade.textContent = 'B+ (Good)';
                    scoreDescription.textContent = 'Suitable for development with moderate grading';
                } else if (score >= 60) {
                    scoreGrade.textContent = 'B (Fair)';
                    scoreDescription.textContent = 'Moderately suitable, significant grading may be required';
                } else if (score >= 50) {
                    scoreGrade.textContent = 'C (Challenging)';
                    scoreDescription.textContent = 'Challenging terrain, extensive grading and engineering required';
                } else {
                    scoreGrade.textContent = 'D (Difficult)';
                    scoreDescription.textContent = 'Very difficult terrain, may not be suitable for development';
                }
            }

            create3DVisualization() {
                console.log('=== CREATING 3D VISUALIZATION ===');
                console.log('Current property for 3D:', this.currentProperty);
                
                // Initialize Three.js if not already done
                if (!this.scene) {
                    console.log('Initializing Three.js...');
                    this.initializeThreeJS();
                }
                
                // Ensure the container is visible
                const container = document.getElementById('threeContainer');
                if (!container) {
                    console.error('Three.js container not found');
                    return;
                }
                
                console.log('Container dimensions:', container.clientWidth, 'x', container.clientHeight);
                console.log('Container visibility:', window.getComputedStyle(container).display);
                console.log('Container position:', container.getBoundingClientRect());
                
                // Clear existing terrain
                const existingTerrain = this.scene.getObjectByName('terrain');
                if (existingTerrain) {
                    console.log('Removing existing terrain');
                    this.scene.remove(existingTerrain);
                }

                console.log('Generating new terrain...');
                const terrain = this.generateTerrain();
                terrain.name = 'terrain';
                this.scene.add(terrain);
                console.log('Terrain added to scene');

                // Add camera controls
                if (!this.controls) {
                    console.log('Setting up camera controls');
                    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                    this.controls.enableDamping = true;
                    this.controls.dampingFactor = 0.05;
                }

                // Position camera for better view
                this.camera.position.set(80, 60, 80);
                this.controls.target.set(0, 0, 0);
                
                // Force a render to ensure the scene is visible
                console.log('Rendering scene...');
                this.renderer.render(this.scene, this.camera);
                
                // Check if the scene has objects
                console.log('Scene objects:', this.scene.children.length);
                console.log('Scene object names:', this.scene.children.map(obj => obj.name));
                
                console.log('3D visualization created successfully');
            }

            generateTerrain() {
                const geometry = new THREE.PlaneGeometry(100, 100, 50, 50);
                const material = new THREE.MeshLambertMaterial({
                    color: 0x4a7c59,
                    wireframe: false,
                    transparent: true,
                    opacity: 0.8
                });

                const terrain = new THREE.Mesh(geometry, material);
                terrain.rotation.x = -Math.PI / 2;
                terrain.receiveShadow = true;

                // Apply elevation based on real GTiff data
                const vertices = geometry.attributes.position.array;
                const samples = this.currentProperty.samples;
                
                if (!samples || samples.length === 0) {
                    console.warn('No elevation samples available, using fallback terrain');
                    // Generate simple fallback terrain
                    for (let i = 0; i < vertices.length; i += 3) {
                        const x = vertices[i];
                        const z = vertices[i + 2];
                        vertices[i + 1] = Math.sin(x * 0.02) * Math.cos(z * 0.02) * 10;
                    }
                } else {
                    console.log('=== GENERATING 3D TERRAIN FROM REAL ELEVATION DATA ===');
                    console.log('Sample count:', samples.length);
                    console.log('First sample:', samples[0]);
                    
                    // Get the bounds of our elevation data
                    const minX = Math.min(...samples.map(s => s.x));
                    const maxX = Math.max(...samples.map(s => s.x));
                    const minZ = Math.min(...samples.map(s => s.y));
                    const maxZ = Math.max(...samples.map(s => s.y));
                    const minElevation = Math.min(...samples.map(s => s.elevation));
                    const maxElevation = Math.max(...samples.map(s => s.elevation));
                    
                    console.log('Elevation bounds:', { minX, maxX, minZ, maxZ, minElevation, maxElevation });
                    console.log('Elevation range:', maxElevation - minElevation);
                    
                    let processedVertices = 0;
                    for (let i = 0; i < vertices.length; i += 3) {
                        const x = vertices[i];
                        const z = vertices[i + 2];
                        
                        // Convert Three.js coordinates (-50 to 50) to elevation data coordinates
                        const dataX = minX + (x + 50) / 100 * (maxX - minX);
                        const dataZ = minZ + (z + 50) / 100 * (maxZ - minZ);
                        
                        // Find the closest elevation sample
                        let closestSample = samples[0];
                        let minDistance = Infinity;
                        
                        for (const sample of samples) {
                            const distance = Math.sqrt((sample.x - dataX) ** 2 + (sample.y - dataZ) ** 2);
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestSample = sample;
                            }
                        }
                        
                        // Scale elevation to fit in 3D view
                        const elevationRange = maxElevation - minElevation;
                        if (elevationRange > 0) {
                            const normalizedElevation = (closestSample.elevation - minElevation) / elevationRange;
                            vertices[i + 1] = normalizedElevation * 30; // Scale to 0-30 range for visualization
                        } else {
                            vertices[i + 1] = 15; // Default height if no elevation range
                        }
                        
                        processedVertices++;
                        if (processedVertices % 100 === 0) {
                            console.log(`Processed ${processedVertices} vertices...`);
                        }
                    }
                    
                    console.log(`Terrain generation complete. Processed ${processedVertices} vertices.`);
                }

                geometry.attributes.position.needsUpdate = true;
                geometry.computeVertexNormals();

                return terrain;
            }

            createSteepnessChart() {
                console.log('Creating steepness chart...');
                console.log('Current property steepness:', this.currentProperty.steepness);
                
                // Check if Chart.js is available
                if (typeof Chart === 'undefined') {
                    console.error('Chart.js not loaded');
                    // Create a fallback display
                    const container = document.getElementById('steepnessChart');
                    container.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;"><h3>Chart Unavailable</h3><p>Steepness data: Flat: ' + 
                        (this.currentProperty.steepness.flat * 100).toFixed(1) + '%, Moderate: ' + 
                        (this.currentProperty.steepness.moderate * 100).toFixed(1) + '%, Steep: ' + 
                        (this.currentProperty.steepness.steep * 100).toFixed(1) + '%</p></div>';
                    return;
                }

                const ctx = document.getElementById('steepnessChart');
                if (!ctx) {
                    console.error('Steepness chart canvas not found');
                    return;
                }
                
                if (this.steepnessChart) {
                    this.steepnessChart.destroy();
                }

                // Ensure we have valid data
                const flatPercent = (this.currentProperty.steepness.flat * 100) || 0;
                const moderatePercent = (this.currentProperty.steepness.moderate * 100) || 0;
                const steepPercent = (this.currentProperty.steepness.steep * 100) || 0;
                
                console.log('Chart data:', [flatPercent, moderatePercent, steepPercent]);

                const data = {
                    labels: ['Flat (0-5%)', 'Moderate (5-15%)', 'Steep (15%+)'],
                    datasets: [{
                        label: 'Percentage of Property',
                        data: [flatPercent, moderatePercent, steepPercent],
                        backgroundColor: [
                            'rgba(72, 187, 120, 0.8)',
                            'rgba(237, 137, 54, 0.8)',
                            'rgba(245, 101, 101, 0.8)'
                        ],
                        borderColor: [
                            'rgba(72, 187, 120, 1)',
                            'rgba(237, 137, 54, 1)',
                            'rgba(245, 101, 101, 1)'
                        ],
                        borderWidth: 2,
                        hoverOffset: 4
                    }]
                };

                try {
                    this.steepnessChart = new Chart(ctx, {
                        type: 'doughnut',
                        data: data,
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            cutout: '60%',
                            legend: {
                                position: 'bottom',
                                labels: {
                                    padding: 20,
                                    usePointStyle: true
                                }
                            },
                            tooltips: {
                                callbacks: {
                                    label: function(tooltipItem, data) {
                                        return data.labels[tooltipItem.index] + ': ' + data.datasets[0].data[tooltipItem.index].toFixed(1) + '%';
                                    }
                                }
                            }
                        }
                    });
                    
                    console.log('Steepness chart created successfully');
                } catch (error) {
                    console.error('Error creating chart:', error);
                    // Fallback to text display
                    const container = document.getElementById('steepnessChart');
                    container.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;"><h3>Chart Error</h3><p>Steepness data: Flat: ' + 
                        flatPercent.toFixed(1) + '%, Moderate: ' + 
                        moderatePercent.toFixed(1) + '%, Steep: ' + 
                        steepPercent.toFixed(1) + '%</p></div>';
                }
            }

            updateBuildableAreas() {
                console.log('Updating buildable areas with property:', this.currentProperty);
                
                const container = document.getElementById('buildableAreas');
                container.innerHTML = '';

                const areas = [
                    {
                        label: 'Highly Buildable',
                        percentage: this.currentProperty.buildable * 100,
                        class: 'buildable',
                        description: 'Flat areas suitable for construction'
                    },
                    {
                        label: 'Moderately Buildable',
                        percentage: this.currentProperty.steepness.moderate * 100,
                        class: 'moderate',
                        description: 'Areas requiring some grading'
                    },
                    {
                        label: 'Challenging',
                        percentage: this.currentProperty.steepness.steep * 100,
                        class: 'steep',
                        description: 'Steep areas requiring extensive work'
                    }
                ];

                console.log('Buildable areas data:', areas);

                areas.forEach(area => {
                    const card = document.createElement('div');
                    card.className = `area-card ${area.class}`;
                    card.innerHTML = `
                        <div class="area-percentage">${area.percentage.toFixed(1)}%</div>
                        <div class="area-label">${area.label}</div>
                        <div class="area-description" style="font-size: 0.9rem; margin-top: 10px; color: #666;">
                            ${area.description}
                        </div>
                    `;
                    container.appendChild(card);
                });
                
                console.log('Buildable areas updated');
            }

            showLoading() {
                document.getElementById('scoreLoading').classList.remove('hidden');
                document.getElementById('topologyScore').classList.add('hidden');
            }

            hideLoading() {
                document.getElementById('scoreLoading').classList.add('hidden');
            }
        }

        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Wait a bit for all scripts to load
            setTimeout(() => {
                // Check if all required libraries are loaded
                if (typeof L === 'undefined') {
                    console.error('Leaflet not loaded');
                    return;
                }
                if (typeof THREE === 'undefined') {
                    console.error('Three.js not loaded');
                    return;
                }
                if (typeof Chart === 'undefined') {
                    console.error('Chart.js not loaded');
                    return;
                }
                
                // Initialize the application
                new TopologyAnalyzer();
            }, 100);
        });
    </script>
</body>
</html>
